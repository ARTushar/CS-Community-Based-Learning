<p>
    A function is a block of organized, reusable code that is used to perform a
    single, related action. Functions provide better modularity for your
    application and a high degree of code reusing.
</p>
<p>
    As you already know, Python gives you many built-in functions like print(),
etc. but you can also create your own functions. These functions are called    <em>user-defined functions.</em>
</p>
<h3>
    Defining a Function
</h3>
<p>
    You can define functions to provide the required functionality. Here are
    simple rules to define a function in Python.
</p>
<ul>
    <li>
        <p>
            Function blocks begin with the keyword def followed by the function
            name and parentheses ( ( ) ).
        </p>
    </li>
    <li>
        <p>
            Any input parameters or arguments should be placed within these
            parentheses. You can also define parameters inside these
            parentheses.
        </p>
    </li>
    <li>
        <p>
            The first statement of a function can be an optional statement -
            the documentation string of the function or <em>docstring</em>.
        </p>
    </li>
    <li>
        <p>
            The code block within every function starts with a colon (:) and is
            indented.
        </p>
    </li>
    <li>
        <p>
            The statement return [expression] exits a function, optionally
            passing back an expression to the caller. A return statement with
            no arguments is the same as return None.
        </p>
    </li>
</ul>
<h3>
    Syntax
</h3>
<pre>def functionname( parameters ):
   "function_docstring"
   function_suite
   return [expression]</pre>
<p>
    By default, parameters have a positional behavior and you need to inform
    them in the same order that they were defined.
</p>
<h3>
    Example
</h3>
<p>
    The following function takes a string as input parameter and prints it on
    standard screen.
</p>
<pre>def printme( str ):
   "This prints a passed string into this function"
   print (str)
   return</pre>
<h2>
    Calling a Function
</h2>
<p>
    Defining a function gives it a name, specifies the parameters that are to
    be included in the function and structures the blocks of code.
</p>
<p>
    Once the basic structure of a function is finalized, you can execute it by
    calling it from another function or directly from the Python prompt.
    Following is an example to call the printme() function −
</p>
<pre>#!/usr/bin/python3

# Function definition is here
def printme( str ):
   "This prints a passed string into this function"
   print (str)
   return

# Now you can call printme function
printme("This is first call to the user defined function!")
printme("Again second call to the same function")</pre>
<p>
    When the above code is executed, it produces the following result −
</p>
<pre>This is first call to the user defined function!
Again second call to the same function
</pre>
<h2>
    Pass by Reference vs Value
</h2>
<p>
    All parameters (arguments) in the Python language are passed by reference.
    It means if you change what a parameter refers to within a function, the
    change also reflects back in the calling function. For example −
</p>
<pre>#!/usr/bin/python3

# Function definition is here
def changeme( mylist ):
   "This changes a passed list into this function"
   print ("Values inside the function before change: ", mylist)
   mylist[2]=50
   print ("Values inside the function after change: ", mylist)
   return

# Now you can call changeme function
mylist = [10,20,30]
changeme( mylist )
print ("Values outside the function: ", mylist)</pre>
<p>
    Here, we are maintaining reference of the passed object and appending
    values in the same object. Therefore, this would produce the following
    result −
</p>
<pre>Values inside the function before change:  [10, 20, 30]
Values inside the function after change:  [10, 20, 50]
Values outside the function:  [10, 20, 50]
</pre>
<p>
    There is one more example where argument is being passed by reference and
    the reference is being overwritten inside the called function.
</p>
<pre>#!/usr/bin/python3

# Function definition is here
def changeme( mylist ):
   "This changes a passed list into this function"
   mylist = [1,2,3,4] # This would assi new reference in mylist
   print ("Values inside the function: ", mylist)
   return

# Now you can call changeme function
mylist = [10,20,30]
changeme( mylist )
print ("Values outside the function: ", mylist)</pre>
<p>
    The parameter mylist is local to the function changeme. Changing mylist
    within the function does not affect mylist. The function accomplishes
    nothing and finally this would produce the following result −
</p>
<pre>Values inside the function:  [1, 2, 3, 4]
Values outside the function:  [10, 20, 30]
</pre>
<h2>
    Function Arguments
</h2>
<p>
    You can call a function by using the following types of formal arguments −
</p>
<ul>
    <li>
        Required arguments
    </li>
    <li>
        Keyword arguments
    </li>
    <li>
        Default arguments
    </li>
    <li>
        Variable-length arguments
    </li>
</ul>
<h2>
    Required Arguments
</h2>
<p>
    Required arguments are the arguments passed to a function in correct
    positional order. Here, the number of arguments in the function call should
    match exactly with the function definition.
</p>
<p>
    To call the function printme(), you definitely need to pass one argument,
    otherwise it gives a syntax error as follows −
</p>
<pre>#!/usr/bin/python3

# Function definition is here
def printme( str ):
   "This prints a passed string into this function"
   print (str)
   return

# Now you can call printme function
printme()</pre>
<p>
    When the above code is executed, it produces the following result −
</p>
<pre>Traceback (most recent call last):
   File "test.py", line 11, in &lt;module&gt;
      printme();
TypeError: printme() takes exactly 1 argument (0 given)
</pre>
<h2>
    Keyword Arguments
</h2>
<p>
    Keyword arguments are related to the function calls. When you use keyword
    arguments in a function call, the caller identifies the arguments by the
    parameter name.
</p>
<p>
    This allows you to skip arguments or place them out of order because the
    Python interpreter is able to use the keywords provided to match the values
    with parameters. You can also make keyword calls to the printme() function
    in the following ways −
</p>
<pre>#!/usr/bin/python3

# Function definition is here
def printme( str ):
   "This prints a passed string into this function"
   print (str)
   return

# Now you can call printme function
printme( str = "My string")</pre>
<p>
    When the above code is executed, it produces the following result −
</p>
<pre>My string
</pre>
<p>
    The following example gives a clearer picture. Note that the order of
    parameters does not matter.
</p>
<pre>#!/usr/bin/python3

# Function definition is here
def printinfo( name, age ):
   "This prints a passed info into this function"
   print ("Name: ", name)
   print ("Age ", age)
   return

# Now you can call printinfo function
printinfo( age = 50, name = "miki" )</pre>
<p>
    When the above code is executed, it produces the following result −
</p>
<pre>Name:  miki
Age  50
</pre>
<h2>
    Default Arguments
</h2>
<p>
    A default argument is an argument that assumes a default value if a value
    is not provided in the function call for that argument. The following
    example gives an idea on default arguments, it prints default age if it is
    not passed −
</p>
<pre>#!/usr/bin/python3

# Function definition is here
def printinfo( name, age = 35 ):
   "This prints a passed info into this function"
   print ("Name: ", name)
   print ("Age ", age)
   return

# Now you can call printinfo function
printinfo( age = 50, name = "miki" )
printinfo( name = "miki" )</pre>
<p>
    When the above code is executed, it produces the following result −
</p>
<pre>Name:  miki
Age  50
Name:  miki
Age  35
</pre>
<h2>
    Variable-length Arguments
</h2>
<p>
    You may need to process a function for more arguments than you specified
while defining the function. These arguments are called    <em>variable-length</em>arguments and are not named in the function
    definition, unlike required and default arguments.
</p>
<p>
    Syntax for a function with non-keyword variable arguments is given below −
</p>
<pre>def functionname([formal_args,] *var_args_tuple ):
   "function_docstring"
   function_suite
   return [expression]</pre>
<p>
    An asterisk (*) is placed before the variable name that holds the values of
    all nonkeyword variable arguments. This tuple remains empty if no
    additional arguments are specified during the function call. Following is a
    simple example −
</p>
<pre>#!/usr/bin/python3

# Function definition is here
def printinfo( arg1, *vartuple ):
   "This prints a variable passed arguments"
   print ("Output is: ")
   print (arg1)
   for var in vartuple:
      print (var)
   return

# Now you can call printinfo function
printinfo( 10 )
printinfo( 70, 60, 50 )</pre>
<p>
    When the above code is executed, it produces the following result −
</p>
<pre>Output is:
10
Output is:
70
60
50
</pre>
<h2>
    The Anonymous Functions
</h2>
<p>
    These functions are called anonymous because they are not declared in the
    standard manner by using the def keyword. You can use the lambda keyword to
    create small anonymous functions.
</p>
<ul>
    <li>
        <p>
            Lambda forms can take any number of arguments but return just one
            value in the form of an expression. They cannot contain commands or
            multiple expressions.
        </p>
    </li>
    <li>
        <p>
            An anonymous function cannot be a direct call to print because
            lambda requires an expression.
        </p>
    </li>
    <li>
        <p>
            Lambda functions have their own local namespace and cannot access
            variables other than those in their parameter list and those in the
            global namespace.
        </p>
    </li>
    <li>
        <p>
            Although it appears that lambdas are a one-line version of a
            function, they are not equivalent to inline statements in C or C++,
            whose purpose is to stack allocation by passing function, during
            invocation for performance reasons.
        </p>
    </li>
</ul>
<h3>
    Syntax
</h3>
<p>
    The syntax of lambda functions contains only a single statement, which is
    as follows −
</p>
<pre>lambda [arg1 [,arg2,.....argn]]:expression</pre>
<p>
    Following is an example to show how lambda form of function works −
</p>
<pre>#!/usr/bin/python3

# Function definition is here
sum = lambda arg1, arg2: arg1 + arg2


# Now you can call sum as a function
print ("Value of total : ", sum( 10, 20 ))
print ("Value of total : ", sum( 20, 20 ))</pre>
<p>
    When the above code is executed, it produces the following result −
</p>
<pre>Value of total :  30
Value of total :  40
</pre>
<h2>
    The return Statement
</h2>
<p>
    The statement return [expression] exits a function, optionally passing back
    an expression to the caller. A return statement with no arguments is the
    same as return None.
</p>
<p>
    All the examples given below are not returning any value. You can return a
    value from a function as follows −
</p>
<pre>#!/usr/bin/python3

# Function definition is here
def sum( arg1, arg2 ):
   # Add both the parameters and return them."
   total = arg1 + arg2
   print ("Inside the function : ", total)
   return total

# Now you can call sum function
total = sum( 10, 20 )
print ("Outside the function : ", total )</pre>
<p>
    When the above code is executed, it produces the following result −
</p>
<pre>Inside the function :  30
Outside the function :  30
</pre>
<h2>
    Scope of Variables
</h2>
<p>
    All variables in a program may not be accessible at all locations in that
    program. This depends on where you have declared a variable.
</p>
<p>
    The scope of a variable determines the portion of the program where you can
    access a particular identifier. There are two basic scopes of variables in
    Python −
</p>
<ul>
    <li>
        Global variables
    </li>
    <li>
        Local variables
    </li>
</ul>
<h2>
    Global vs. Local variables
</h2>
<p>
    Variables that are defined inside a function body have a local scope, and
    those defined outside have a global scope.
</p>
<p>
    This means that local variables can be accessed only inside the function in
    which they are declared, whereas global variables can be accessed
    throughout the program body by all functions. When you call a function, the
    variables declared inside it are brought into scope. Following is a simple
    example −
</p>
<pre>#!/usr/bin/python3

total = 0 # This is global variable.
# Function definition is here
def sum( arg1, arg2 ):
   # Add both the parameters and return them."
   total = arg1 + arg2; # Here total is local variable.
   print ("Inside the function local total : ", total)
   return total

# Now you can call sum function
sum( 10, 20 )
print ("Outside the function global total : ", total )</pre>
<p>
    When the above code is executed, it produces the following result −
</p>
<pre>Inside the function local total :  30
Outside the function global total :  0</pre>